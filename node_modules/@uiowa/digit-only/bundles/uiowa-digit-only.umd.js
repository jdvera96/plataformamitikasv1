(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core')) :
    typeof define === 'function' && define.amd ? define('@uiowa/digit-only', ['exports', '@angular/core'], factory) :
    (global = global || self, factory((global.uiowa = global.uiowa || {}, global.uiowa['digit-only'] = {}), global.ng.core));
}(this, (function (exports, core) { 'use strict';

    var DigitOnlyDirective = /** @class */ (function () {
        function DigitOnlyDirective(el) {
            this.el = el;
            this.hasDecimalPoint = false;
            this.navigationKeys = [
                'Backspace',
                'Delete',
                'Tab',
                'Escape',
                'Enter',
                'Home',
                'End',
                'ArrowLeft',
                'ArrowRight',
                'Clear',
                'Copy',
                'Paste',
            ];
            this.decimal = false;
            this.decimalSeparator = '.';
            this.min = -Infinity;
            this.max = Infinity;
            this.inputElement = el.nativeElement;
        }
        DigitOnlyDirective.prototype.ngOnChanges = function (changes) {
            if (changes.pattern) {
                this.regex = this.pattern ? RegExp(this.pattern) : null;
            }
            if (changes.min) {
                var maybeMin = Number(this.min);
                this.min = isNaN(maybeMin) ? -Infinity : maybeMin;
            }
            if (changes.max) {
                var maybeMax = Number(this.max);
                this.max = isNaN(maybeMax) ? Infinity : maybeMax;
            }
        };
        DigitOnlyDirective.prototype.onKeyDown = function (e) {
            if (this.navigationKeys.indexOf(e.key) > -1 || // Allow: navigation keys: backspace, delete, arrows etc.
                (e.key === 'a' && e.ctrlKey === true) || // Allow: Ctrl+A
                (e.key === 'c' && e.ctrlKey === true) || // Allow: Ctrl+C
                (e.key === 'v' && e.ctrlKey === true) || // Allow: Ctrl+V
                (e.key === 'x' && e.ctrlKey === true) || // Allow: Ctrl+X
                (e.key === 'a' && e.metaKey === true) || // Allow: Cmd+A (Mac)
                (e.key === 'c' && e.metaKey === true) || // Allow: Cmd+C (Mac)
                (e.key === 'v' && e.metaKey === true) || // Allow: Cmd+V (Mac)
                (e.key === 'x' && e.metaKey === true) // Allow: Cmd+X (Mac)
            ) {
                // let it happen, don't do anything
                return;
            }
            var newValue = '';
            if (this.decimal && e.key === this.decimalSeparator) {
                newValue = this.forecastValue(e.key);
                if (newValue.split(this.decimalSeparator).length > 2) { // has two or more decimal points
                    e.preventDefault();
                    return;
                }
                else {
                    this.hasDecimalPoint = newValue.indexOf(this.decimalSeparator) > -1;
                    return; // Allow: only one decimal point
                }
            }
            // Ensure that it is a number and stop the keypress
            if (e.key === ' ' || isNaN(Number(e.key))) {
                e.preventDefault();
                return;
            }
            newValue = newValue || this.forecastValue(e.key);
            // check the input pattern RegExp
            if (this.regex) {
                if (!this.regex.test(newValue)) {
                    e.preventDefault();
                    return;
                }
            }
            var newNumber = Number(newValue);
            if (newNumber > this.max || newNumber < this.min) {
                e.preventDefault();
            }
        };
        DigitOnlyDirective.prototype.onPaste = function (event) {
            var pastedInput;
            if (window['clipboardData']) {
                // Browser is IE
                pastedInput = window['clipboardData'].getData('text');
            }
            else if (event.clipboardData && event.clipboardData.getData) {
                // Other browsers
                pastedInput = event.clipboardData.getData('text/plain');
            }
            this.pasteData(pastedInput);
            event.preventDefault();
        };
        DigitOnlyDirective.prototype.onDrop = function (event) {
            var textData = event.dataTransfer.getData('text');
            this.inputElement.focus();
            this.pasteData(textData);
            event.preventDefault();
        };
        DigitOnlyDirective.prototype.pasteData = function (pastedContent) {
            var sanitizedContent = this.sanitizeInput(pastedContent);
            var pasted = document.execCommand('insertText', false, sanitizedContent);
            if (!pasted) {
                if (this.inputElement.setRangeText) {
                    var _a = this.inputElement, start = _a.selectionStart, end = _a.selectionEnd;
                    this.inputElement.setRangeText(sanitizedContent, start, end, 'end');
                }
                else {
                    // Browser does not support setRangeText, e.g. IE
                    this.insertAtCursor(this.inputElement, sanitizedContent);
                }
            }
            if (this.decimal) {
                this.hasDecimalPoint =
                    this.inputElement.value.indexOf(this.decimalSeparator) > -1;
            }
        };
        // The following 2 methods were added from the below article for browsers that do not support setRangeText
        // https://stackoverflow.com/questions/11076975/how-to-insert-text-into-the-textarea-at-the-current-cursor-position
        DigitOnlyDirective.prototype.insertAtCursor = function (myField, myValue) {
            var startPos = myField.selectionStart;
            var endPos = myField.selectionEnd;
            myField.value =
                myField.value.substring(0, startPos) +
                    myValue +
                    myField.value.substring(endPos, myField.value.length);
            var pos = startPos + myValue.length;
            myField.focus();
            myField.setSelectionRange(pos, pos);
            this.triggerEvent(myField, 'input');
        };
        DigitOnlyDirective.prototype.triggerEvent = function (el, type) {
            if ('createEvent' in document) {
                // modern browsers, IE9+
                var e = document.createEvent('HTMLEvents');
                e.initEvent(type, false, true);
                el.dispatchEvent(e);
            }
        };
        // end stack overflow code
        DigitOnlyDirective.prototype.sanitizeInput = function (input) {
            var result = '';
            if (this.decimal && this.isValidDecimal(input)) {
                var regex = new RegExp("[^0-9" + this.decimalSeparator + "]", 'g');
                result = input.replace(regex, '');
            }
            else {
                result = input.replace(/[^0-9]/g, '');
            }
            var maxLength = this.inputElement.maxLength;
            if (maxLength > 0) {
                // the input element has maxLength limit
                var allowedLength = maxLength - this.inputElement.value.length;
                result = allowedLength > 0 ? result.substring(0, allowedLength) : '';
            }
            return result;
        };
        DigitOnlyDirective.prototype.isValidDecimal = function (string) {
            if (!this.hasDecimalPoint) {
                return string.split(this.decimalSeparator).length <= 2;
            }
            else {
                // the input element already has a decimal separator
                var selectedText = this.getSelection();
                if (selectedText && selectedText.indexOf(this.decimalSeparator) > -1) {
                    return string.split(this.decimalSeparator).length <= 2;
                }
                else {
                    return string.indexOf(this.decimalSeparator) < 0;
                }
            }
        };
        DigitOnlyDirective.prototype.getSelection = function () {
            return this.inputElement.value.substring(this.inputElement.selectionStart, this.inputElement.selectionEnd);
        };
        DigitOnlyDirective.prototype.forecastValue = function (key) {
            var selectionStart = this.inputElement.selectionStart;
            var selectionEnd = this.inputElement.selectionEnd;
            var oldValue = this.inputElement.value;
            var selection = oldValue.substring(selectionStart, selectionEnd);
            return selection
                ? oldValue.replace(selection, key)
                : oldValue.substring(0, selectionStart) +
                    key +
                    oldValue.substring(selectionStart);
        };
        return DigitOnlyDirective;
    }());
    DigitOnlyDirective.decorators = [
        { type: core.Directive, args: [{
                    selector: '[digitOnly]',
                },] }
    ];
    DigitOnlyDirective.ctorParameters = function () { return [
        { type: core.ElementRef }
    ]; };
    DigitOnlyDirective.propDecorators = {
        decimal: [{ type: core.Input }],
        decimalSeparator: [{ type: core.Input }],
        min: [{ type: core.Input }],
        max: [{ type: core.Input }],
        pattern: [{ type: core.Input }],
        onKeyDown: [{ type: core.HostListener, args: ['keydown', ['$event'],] }],
        onPaste: [{ type: core.HostListener, args: ['paste', ['$event'],] }],
        onDrop: [{ type: core.HostListener, args: ['drop', ['$event'],] }]
    };

    var MaskDirective = /** @class */ (function () {
        function MaskDirective(el) {
            this.el = el;
            this.navigationKeys = [
                'Backspace',
                'Delete',
                'Tab',
                'Escape',
                'Enter',
                'Home',
                'End',
                'ArrowLeft',
                'ArrowRight',
                'Clear',
                'Copy',
                'Paste',
            ];
            this.inputElement = el.nativeElement;
            this.regex = new RegExp(this.inputElement.pattern);
        }
        MaskDirective.prototype.onKeyDown = function (e) {
            if (this.navigationKeys.indexOf(e.key) > -1 || // Allow: navigation keys: backspace, delete, arrows etc.
                (e.key === 'a' && e.ctrlKey === true) || // Allow: Ctrl+A
                (e.key === 'c' && e.ctrlKey === true) || // Allow: Ctrl+C
                (e.key === 'v' && e.ctrlKey === true) || // Allow: Ctrl+V
                (e.key === 'x' && e.ctrlKey === true) || // Allow: Ctrl+X
                (e.key === 'a' && e.metaKey === true) || // Allow: Cmd+A (Mac)
                (e.key === 'c' && e.metaKey === true) || // Allow: Cmd+C (Mac)
                (e.key === 'v' && e.metaKey === true) || // Allow: Cmd+V (Mac)
                (e.key === 'x' && e.metaKey === true) // Allow: Cmd+X (Mac)
            ) {
                // let it happen, don't do anything
                return;
            }
            var newValue = this.forecastValue(e.key);
            if (!this.regex.test(newValue)) {
                e.preventDefault();
            }
        };
        MaskDirective.prototype.forecastValue = function (key) {
            var selectionStart = this.inputElement.selectionStart;
            var selectionEnd = this.inputElement.selectionEnd;
            var oldValue = this.inputElement.value;
            var selection = oldValue.substring(selectionStart, selectionEnd);
            return selection
                ? oldValue.replace(selection, key)
                : oldValue.substring(0, selectionStart) +
                    key +
                    oldValue.substring(selectionStart);
        };
        return MaskDirective;
    }());
    MaskDirective.decorators = [
        { type: core.Directive, args: [{
                    selector: '[mask]',
                },] }
    ];
    MaskDirective.ctorParameters = function () { return [
        { type: core.ElementRef }
    ]; };
    MaskDirective.propDecorators = {
        onKeyDown: [{ type: core.HostListener, args: ['keydown', ['$event'],] }]
    };

    var DigitOnlyModule = /** @class */ (function () {
        function DigitOnlyModule() {
        }
        return DigitOnlyModule;
    }());
    DigitOnlyModule.decorators = [
        { type: core.NgModule, args: [{
                    imports: [],
                    declarations: [DigitOnlyDirective, MaskDirective],
                    exports: [DigitOnlyDirective, MaskDirective],
                },] }
    ];

    /*
     * Public API Surface of digit-only
     */

    /**
     * Generated bundle index. Do not edit.
     */

    exports.DigitOnlyDirective = DigitOnlyDirective;
    exports.DigitOnlyModule = DigitOnlyModule;
    exports.MaskDirective = MaskDirective;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=uiowa-digit-only.umd.js.map
